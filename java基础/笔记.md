**Integer 对象的两种创建方式**

1. **直接赋值:** 例如：Integer a = 1;
2. **构造函数：** 例如：Integer a = new Integer(1);
   **直接赋值方式**：通过 IntegerCache 对象缓存进行复制，缓存数值的范围为 [-128, 127];
   **构造函数方式**：通过 Integer 的构造函数创建的 Integer 对象，不会从缓存中赋值，而是创建一个新的对象。
   注：为什么数值 1 可以直接赋值给 Integer 对象，请查看 **装箱和拆箱**。

使用HashMap实现LRU算法：

> LinkedHashMap自带的两个方法：
>
> 1. removeEldestEntry（）：根据某种判断来删除map里面的数据
> 2. 构造方法super(capacity,0.75f,true);//true代表访问顺序、false代表插入顺序

```java
//继承LinkedHashMap实现自定义LRU算法HashMap
class LRULinkedHashMap<K,V> extends LinkedHashMap<K,V> {

	private static final long serialVersionUID = 1882839504956564761L;
	
	private int capacity;
	//重写LinkedHashMap方法
	public LRULinkedHashMap(int capacity) {
		super(capacity,0.75f,true);//true代表访问顺序、false代表插入顺序
		this.capacity = capacity;
	}

	@Override
	public boolean removeEldestEntry(Map.Entry<K,V> eldest) {
		System.out.println("即将根据LRU算法，删除最近最少使用元素：key= "+eldest.getKey()+" value= "+eldest.getValue()+" .");
		//此行代码是关键，一旦容量超出限制，即按照LRU进行删除
        return size()>capacity;
    } 
}
public class Test {
	public static void main(String[] args) {		
		testLRULinkedHashMap();
	}
}
public static void testLRULinkedHashMap() {
		//容量固定，accessOrder=true
		Map<Integer, Integer> map = new LRULinkedHashMap<Integer, Integer>(5);
		map.put(1, 1);
		map.put(2, 2);
		map.put(3, 3);
		map.put(4, 4);
		map.put(5, 5);
		
		//此时输出1,2,3,4,5
		for(Iterator<Map.Entry<Integer, Integer>> it = map.entrySet().iterator(); it.hasNext();) {
			System.out.println(it.next().getValue());
		}
		map.put(4, 4);
		map.put(6, 6);
		
		//此时输出2,3,5,4,6（容量锁定，删除5来新增6）
		for(Iterator<Map.Entry<Integer, Integer>> it = map.entrySet().iterator(); it.hasNext();) {
			System.out.println(it.next().getValue());
		}
		
	}
```

### 八种基本类型：

| 基本类型 | 包装类型  |
| -------- | --------- |
| byte     | Byte      |
| short    | Short     |
| int      | Integer   |
| long     | Long      |
| float    | Float     |
| double   | Double    |
| char     | Character |
| boolean  | Boolean   |

#### 数组/链表/哈希表/树结构对于增删改的优缺点

##### 数组： 

　　优点：

　　1. 数组的主要优点是根据下标值访问效率会很高

　　2.但是如果希望根据元素来查找对应的位置？

　　3.比较好的方法是先对数组排序，再进行二分查找

　　缺点：

　　需要先对数组排序，生成有序数组，才能提高查找效率

　　数组在插入和删除数据时，需要有大量的位移操作（插入中间或者首部时），效率很低

##### 链表：

　　优点：

　　1.链表的插入和删除操作效率都很高

　　缺点：

　　查找效率低，需要从头依次查找链表的每一项

　　即使插入和删除效率高，但是如果插入和删除中间位置，还是要重头找到对应的数据

##### 哈希表：

　　优点： 插入/查询/删除效率非常高

　　缺点：

　　1.空间利用率不高，底层使用的是数组，并且使用的某些单元是没有被利用的

　　2.哈希表中的元素是无序的，不能按照固定的顺序来遍历哈希表中的元素

　　3.不能快速的找出哈希表中的最大值或者最小值

##### 树结构：

　　在某种场景下，使用树结构会更加方便

　　因为树结构是非线性，可以表示一对多

　　比如文件的目录结构

　　对于一个平衡树的插入和查找等效率为O(logN)   平衡树： 树两边的数据均匀分布 非平衡树： 树两边的数据不均匀分布

　　连续插入有序的数据，树分布不均匀，变成一个链表结构，插入和查找等效率变成 O(N)　　

### B-tree介绍：



#### 查询数据过程：

![img](https://img-blog.csdn.net/20180911102554417?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E3NjQzNDA3MDM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

模拟查找关键字29的过程：

1. 根据根节点找到磁盘块1，读入内存。【磁盘I/O操作第1次】
2. 比较关键字29在区间（17,35），找到磁盘块1的指针P2。
3. 根据P2指针找到磁盘块3，读入内存。【磁盘I/O操作第2次】
4. 比较关键字29在区间（26,30），找到磁盘块3的指针P2。
5. 根据P2指针找到磁盘块8，读入内存。【磁盘I/O操作第3次】
6. 在磁盘块8中的关键字列表中找到关键字29。

### B+tree介绍：

#### 查询数据过程：

![img](https://img-blog.csdn.net/20180911102523256?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E3NjQzNDA3MDM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

和B-tree查询过程一样，只是数据都存在于叶子节点，由于所有叶子节点之间都有一个链指针，所以B+tree还提供范围查询。

#### B+tree和B-tree的区别：

1. B+tree所有叶子节点之间都有一个链指针。
2. B+tree数据记录都存放在叶子节点中。
3. B+tree查询的时间复杂度是固定为logn，B-树查询时间复杂度不固定，与 key 在树中的位置有关，最好为O(1)。（B-Tree的平均性能逼近二分查找）

补充：https://mp.weixin.qq.com/s/qV3XmarTz9hPFCMN7_KKhg



