单点登录：

前端使用body和密码加密，后端同样使用body和密码加密（为了防止body篡改），进行对比。

<img src="D:\study\学习资料\每阶段资料\解压包\项目资料\讲义\md图片\image-20200908164154716.png" style="zoom:60%;" />

#### 获取Token流程：

##### UserController.login()：

```java
 @PostMapping("login")
    public ResponseDTO<String> login(@ApiParam(name = "phone", value = "手机号", required = true) String phone,  @ApiParam(name = "password", value = "密码") String password,
			@ApiParam(name = "code", value = "验证码") String code, Logger log) {
        
        if (StringUtils.isEmpty(phone) || !RegexUtil.isPhone(phone)) {
            return ResponseDTO.ofError(201, "非法的手机号");
        }
        if (StringUtils.isEmpty(password) && StringUtils.isEmpty(code)) {
            return ResponseDTO.ofError(202, "密码或者验证码为空");
        }
        // 默认是账号密码登录
        Integer type = 0;
        if (StringUtils.isEmpty(password) && StringUtils.isNotEmpty(code)) {
            type = 1;
        }

        // 判断手机号是否有注册
        boolean isRegister = this.userRemoteService.isRegister(phone);
        if (!Boolean.TRUE.equals(isRegister)) {
            // 不允许直接手机号+密码注册并登录
            if (type == 0) {
                log.info("该手机号[{}]未注册,不允许手机号+密码注册", phone);
                return ResponseDTO.ofError(205, "手机号或者密码错误");
            }
            UserDTO dto = new UserDTO();
            dto.setAccountNonExpired(true);
            dto.setAccountNonLocked(true);
            dto.setCredentialsNonExpired(true);
            dto.setStatus("ENABLE");
            dto.setRegIp(UserManager.getUserIP());
            dto.setName(phone);
            dto.setPassword(type == 0 ? password : phone);
            dto.setCreateTime(new Date());
            dto.setDel(false);
            dto.setPhone(phone);
            dto.setUpdateTime(new Date());
            dto.setPortrait(null);
            UserDTO newUser = this.userRemoteService.saveUser(dto);
            log.info("用户[{}]注册成功", newUser);
        }
        return this.userService.createAuthToken(phone, password, code, type);
    }
```

##### UserService.createAuthToken()：

```java
public ResponseDTO<String> createAuthToken(String phone, String password, String code, Integer type) { //type为登录类型
        log.info("phone:{}, password:{}, scope:{}, grantType:{}, clientId:{}, clientSecret:{}", phone, password, scope, grantType, clientId, clientSecret);
        String token = null;
        try {
            if (0 == type) { 
                token = this.oAuthRemoteService.createToken(phone, password, scope, grantType, clientId, clientSecret, null);
            } else if (1 == type) {
                token = this.oAuthRemoteService.createToken(phone, code, scope, grantType, clientId, clientSecret, "mobile");
            } else if (2 == type) {
                token = this.oAuthRemoteService.createToken(phone, code, scope, grantType, clientId, clientSecret, "weixin");
            }
            if (StringUtils.isBlank(token)) {
                return ResponseDTO.ofError(206, "登录失败");
            }
            JSONObject jsonObject = JSON.parseObject(token);
            String resultCode = jsonObject.getString("code");
            if (StringUtils.isNotBlank(resultCode)) {
                log.info("phone:{}, jwt token is null, token:{}", phone, token);
                if ("040072".equals(resultCode)) {
                    return ResponseDTO.ofError(207, "验证码错误(" + resultCode + ")");
                }
                return ResponseDTO.ofError(206, "登录失败(" + resultCode + ")");
            }
            String userId = jsonObject.getString("user_id");
            if (StringUtils.isBlank(userId)) {
                return ResponseDTO.response(-1, "login fail", null);
            }
            return ResponseDTO.response(1, "success", token);
        } catch (Exception e) {
            log.error("", e);
            return ResponseDTO.ofError(206, "登录失败");
        }
    }
```

项目中使用到的设计模式



### 权限管理：

- #### 角色管理：

  - ##### 操作界面：

    - 角色编辑页面：

    ![image-20210411190640938](C:\Users\12031\AppData\Roaming\Typora\typora-user-images\image-20210411190640938.png)

    - 用户分配角色：

    <img src="C:\Users\12031\AppData\Roaming\Typora\typora-user-images\image-20210411192124991.png" alt="image-20210411192124991" style="zoom:200%;" />

  - ##### 相关表：

    - 角色表（roles）：

      ![image-20210411191253501](C:\Users\12031\AppData\Roaming\Typora\typora-user-images\image-20210411191253501.png)

      ![image-20210411191025466](C:\Users\12031\AppData\Roaming\Typora\typora-user-images\image-20210411191025466.png)

    - 用户-角色关系表(user_role_relation)：

      ![image-20210411193843312](C:\Users\12031\AppData\Roaming\Typora\typora-user-images\image-20210411193843312.png)

    - 角色-菜单关系表(role_menu_relation)

      ![image-20210411193906537](C:\Users\12031\AppData\Roaming\Typora\typora-user-images\image-20210411193906537.png)

      ![image-20210411193916234](C:\Users\12031\AppData\Roaming\Typora\typora-user-images\image-20210411193916234.png)

    - 角色-资源关系表(role_resource_relation)

      ![image-20210411193941132](C:\Users\12031\AppData\Roaming\Typora\typora-user-images\image-20210411193941132.png)

  - 相关接口：

    |          |                                                              |
    | -------- | ------------------------------------------------------------ |
    | 功能名称 | 角色管理                                                     |
    | 功能描述 | 1.添加、修改角色，查看角色列表；<br/>2.给用户分配多个角色，用户通过角色来关联可访问的菜单、资源；<br/>3.删除角色，删除角色时级联删除用户-角色关系，角色-菜单关系，角色-资源关系； |
    | 功能接口 | 1.获取登录用户菜单及可访问资源列表：/boss/permission/getUserPermissions<br/>2.保存或者更新角色：/boss/role/saveOrUpdate<br/>3.按条件查询角色：/boss/role/getRolePages<br/>4.删除角色：/boss/role/{id}DELETE<br/>5.给用户分配角色：/boss/role/allocateUserRoles |

    复杂接口说明：

    - ##### 获取登录用户菜单及可访问资源列表：

      - ###### 菜单权限控制：

        跟据用户获取角色列表，再通过角色获取菜单列表（带层级的）并进行展示。

      - ###### 资源权限控制：

        在网关拦截带bms路径的请求，然后通过用户获取角色，通过角色获取资源，校验该资源是否存在，不存在则没权限。

    - ##### 删除角色：
    
      删除角色时级联删除用户-角色关系，角色-菜单关系，角色-资源关系。
    
    - ##### 给用户重新分配角色：
    
      1. 先根据用户ID在用户-角色关系表找到该用户的数据，然后进行删除。
      2. 将需要添加的用户-角色关系批量添加到用户-角色关系表。
      
      
  
- ### 菜单管理：

  - ##### 操作界面：

    - 角色分配菜单：

    ![image-20210411195033543](C:\Users\12031\AppData\Roaming\Typora\typora-user-images\image-20210411195033543.png)

    - 菜单编辑页面：

    ![image-20210411194315608](C:\Users\12031\AppData\Roaming\Typora\typora-user-images\image-20210411194315608.png)

    显示菜单信息以及上级菜单列表并选中：

    ![image-20210411200322838](C:\Users\12031\AppData\Roaming\Typora\typora-user-images\image-20210411200322838.png)

  - ##### 相关表：

    - 菜单表(menu)：

      ![image-20210411194416790](C:\Users\12031\AppData\Roaming\Typora\typora-user-images\image-20210411194416790.png)

      ![image-20210411194427850](C:\Users\12031\AppData\Roaming\Typora\typora-user-images\image-20210411194427850.png)

    - 角色-菜单关系表(role_menu_relation)：

      ![image-20210411193906537](C:\Users\12031\AppData\Roaming\Typora\typora-user-images\image-20210411193906537.png)

      ![image-20210411193916234](C:\Users\12031\AppData\Roaming\Typora\typora-user-images\image-20210411193916234.png)

  - 相关接口：

    ![image-20210411194623336](C:\Users\12031\AppData\Roaming\Typora\typora-user-images\image-20210411194623336.png)

    复杂接口说明：

    - 删除菜单：

      删除菜单，删除菜单时级联删除角色-菜单关系。

    - 获取角色拥有的菜单列表（进入该页面）：

      <img src="C:\Users\12031\AppData\Roaming\Typora\typora-user-images\image-20210411201631063.png" alt="image-20210411201631063" style="zoom:70%;" />

      ```java
    @ApiOperation(value = "获取角色拥有的菜单列表", notes = "在给角色分配菜单时，跳转到角色-菜单列表页，并标记哪些菜单已分配给该角色")
          @GetMapping("/getRoleMenus")
        public Result<List<MenuNodeDTO>> getRoleMenus(@RequestParam Integer roleId) {
              //1.获取角色对应的菜单列表
              Result<List<MenuDTO>> menusResult = menuProvider.getByRoleId(roleId);
      		//2.获取带层级的菜单列表
              Result<List<MenuNodeDTO>> menuNodeListResult = menuProvider.getMenuNodeList();
      
              List<MenuDTO> roleMenus = Lists.newArrayList();
              if (menusResult.isSuccess() && CollectionUtils.isNotEmpty(menusResult.getData())) {
                  roleMenus = menusResult.getData();
              }
      
              List<MenuNodeDTO> menuNodes = Lists.newArrayList();
              if (menuNodeListResult.isSuccess() && CollectionUtils.isNotEmpty(menuNodeListResult.getData())) {
                  menuNodes = menuNodeListResult.getData();
              }
      
              if (CollectionUtils.isEmpty(menuNodes)) {
                  return Result.fail("未查询到菜单列表");
              }
      		//3.获取当前菜单的parent_Id，遍历带层级的菜单列表
              final Set<Integer> roleMenuIds = roleMenus.stream().map(role -> role.getId()).collect(Collectors.toSet());
              menuNodes.stream().forEach(menuNodeDTO -> setSelectedFlag(menuNodeDTO, roleMenuIds));
      
              return Result.success(menuNodes);
          }
      
      private void setSelectedFlag(MenuNodeDTO menuNodeDTO, Set<Integer> roleMenuIds) {
          	//4.如果该菜单的id和parent_Id，则置为选中状态
              if (roleMenuIds.contains(menuNodeDTO.getId())) {
                  menuNodeDTO.setSelected(true);
              }
              if (CollectionUtils.isEmpty(menuNodeDTO.getSubMenuList())) {
                  return;
              }
         		 //5.不满足条件，递归调用
              menuNodeDTO.getSubMenuList().stream().forEach(subMenuNode -> setSelectedFlag(subMenuNode, roleMenuIds));
          }
      
      ```
    
      

    - 获取所有菜单并按层级展示（上图的所有展示）：

      实现思路及其代码：

      ```java
    /**
        *获取所有菜单
      */
      @Override
        public List<MenuNodeDTO> getMenuNodeList() {
              QueryWrapper<Menu> queryWrapper = new QueryWrapper();
              queryWrapper.eq("level", PubContants.MENU_TOP_LEVEL);
              //1.获取所有的菜单列表
              List<Menu> topLevelMenuList = this.list(queryWrapper);
              if (CollectionUtils.isEmpty(topLevelMenuList)) {
                  return Lists.newArrayList();
              }
              //2.遍历每个菜单下的子菜单
              List<MenuNodeDTO> menuNodeList = topLevelMenuList.stream().map(menu -> fillMenuNode(menu)).collect(Collectors.toList());
              Collections.sort(menuNodeList);
              return menuNodeList;
          }
      /**
        *查询子菜单
        */
          @Override
          public MenuNodeDTO fillMenuNode(Menu menu) {
              MenuNodeDTO menuNodeDTO = ConvertUtils.convert(menu, MenuNodeDTO.class);
              QueryWrapper queryWrapper = new QueryWrapper();
              //3.将该菜单的id作为parent_id
              queryWrapper.eq("parent_id", menuNodeDTO.getId());
              //4.查询其他菜单的parent_id和它相等的列表
              List<Menu> list = this.list(queryWrapper);
              if (CollectionUtils.isEmpty(list)) {
                  return menuNodeDTO;
              }
              //5.递归调用，因为还可能有3、4级菜单。
              List<MenuNodeDTO> subMenuList = list.stream().map(subMenu -> fillMenuNode(subMenu)).collect(Collectors.toList()); 
              Collections.sort(subMenuList);
              //6.将子菜单放入MenuNodeDTO的SubMenuList集合中，这个SubMenuList就是该菜单的子菜单集合。
              menuNodeDTO.setSubMenuList(subMenuList);
              return menuNodeDTO;
          }
      ```
    
    - 给角色分配菜单（点上图的保存按钮）：
    
      ```java
        	@Override
          @Transactional(rollbackFor = Exception.class)
          public void allocateRoleMenus(AllocateRoleMenuDTO allocateRoleMenuDTO) {
              if (CollectionUtils.isEmpty(allocateRoleMenuDTO.getMenuIdList())) {
                  allocateRoleMenuDTO.setMenuIdList(Lists.newArrayList());
              }
              // 1.获取角色已拥有的菜单
              Set<Integer> roleMenuIds = roleMenuService.queryByRoleIds(Sets.newHashSet(allocateRoleMenuDTO.getRoleId()));
              // 2.获取准备分配给角色的菜单，排除掉 -1(-1是不存在的id，是顶级菜单的父ID)
              Set<Integer> allocateRoleMenuIds = allocateRoleMenuDTO.getMenuIdList().stream()
                      .filter(menuId -> !Objects.equals(menuId, PubContants.MENU_TOP_LEVEL_PARENT_ID)).collect(Collectors.toSet());
      
              // 3.找出本次删除的（将已拥有的删除）
              Set<Integer> needToDelMenus = roleMenuIds.stream().filter(id -> !allocateRoleMenuIds.contains(id)).collect(Collectors.toSet());
              // 4.找出本次新增的（将上传的添加）
              Set<Integer> needToInsertMenus = allocateRoleMenuIds.stream().filter(id -> !roleMenuIds.contains(id)).collect(Collectors.toSet());
      
              if (CollectionUtils.isNotEmpty(needToDelMenus)) {
            roleMenuService.removeByRoleIdAndMenuIds(allocateRoleMenuDTO.getRoleId(), needToDelMenus);
              }
      
              if (CollectionUtils.isNotEmpty(needToInsertMenus)) {
                List<RoleMenu> roleMenus = needToInsertMenus.stream().map(menuId -> {
                      RoleMenu roleMenu = new RoleMenu();
                      roleMenu.setRoleId(allocateRoleMenuDTO.getRoleId());
                      roleMenu.setMenuId(menuId);
                      roleMenu.setCreatedBy(allocateRoleMenuDTO.getCreatedBy());
                      roleMenu.setUpdatedBy(allocateRoleMenuDTO.getUpdatedBy());
                      roleMenu.setCreatedTime(new Date());
                      roleMenu.setUpdatedTime(new Date());
                      return roleMenu;
                  }).collect(Collectors.toList());
                  roleMenuService.saveBatch(roleMenus);
              }
          }
      ```
    
      ![image-20210412225359237](C:\Users\12031\AppData\Roaming\Typora\typora-user-images\image-20210412225359237.png)
    
    - 获取菜单详情并展示上级菜单列表以及选中：
    
      ![image-20210411201923322](C:\Users\12031\AppData\Roaming\Typora\typora-user-images\image-20210411201923322.png)
    
      实现代码：
      
      ```java
       @GetMapping("/getEditMenuInfo")
          public Result<Map> getEditMenuInfo(@RequestParam("id") Integer id) {
              Map<String, Object> resultMap = new HashMap<>();
              MenuDTO menuDTO = null;
              List<MenuNodeDTO> menuNodeDTOList = Lists.newArrayList();
               //1.获取带层级的菜单列表（对应上面的getMenuNodeList）
              Result<List<MenuNodeDTO>> menuNodeListResult = menuProvider.getMenuNodeList();
              //2.获取菜单详情
              Result<MenuDTO> menuResult = menuProvider.getById(id); 
              if (menuNodeListResult.isSuccess() && CollectionUtils.isNotEmpty(menuNodeListResult.getData())) {
                  menuNodeDTOList = menuNodeListResult.getData();
              }
      
              if (menuResult.isSuccess() && Objects.nonNull(menuResult.getData())) {
                  menuDTO = menuResult.getData();
              }
      
              if (Objects.nonNull(menuDTO)) {
                  //3.获取当前菜单的parent_Id，遍历带层级的菜单列表
                  Integer parentId = menuDTO.getParentId();
                  menuNodeDTOList.stream().forEach(menuNodeDTO -> setSelectedFlag(parentId, menuNodeDTO));
              }
      		
              resultMap.put("menuInfo", menuDTO);
              //6.将选中状态的带层级的菜单列表返回给前端，前端需要判断哪个层级有菜单为选中状态，如果有的话获取该层级菜单展示。
              resultMap.put("parentMenuList", menuNodeDTOList);
              return Result.success(resultMap);
          }
      
      private void setSelectedFlag(Integer parentId, MenuNodeDTO menuNodeDTO) {
          	//4.如果该菜单的id和parent_Id，则置为选中状态
              if (Objects.equals(menuNodeDTO.getId(), parentId)) {
                  menuNodeDTO.setSelected(true);
                  return;
              }
              if (CollectionUtils.isEmpty(menuNodeDTO.getSubMenuList())) {
                  return;
              }
          	//5.不满足条件，递归调用
              menuNodeDTO.getSubMenuList().stream().forEach(subMenuNode -> setSelectedFlag(parentId, subMenuNode));
          }
      
      ```

- ### 资源管理：

  - 操作界面：
  
    资源展示页面：
  
    ![image-20210413230539662](C:\Users\12031\AppData\Roaming\Typora\typora-user-images\image-20210413230539662.png)
  
    资源分类展示页面：
  
    ![image-20210413231026503](C:\Users\12031\AppData\Roaming\Typora\typora-user-images\image-20210413231026503.png)
  
    基本的增删改查，删除的时候如果资源分类下面还有资源则不可以删除。
  
  

### 消息推送模块：

> #### websocket 和 socket.io 之间的区别：
>
> socket.io封装了websocket，同时包含了其它的连接方式，比如Ajax。原因在于不是所有的浏览器都支持websocket，通过socket.io的封装，你不用关心里面用了什么连接方式。你在任何浏览器里都可以使用socket.io来建立异步的连接。socket.io包含了服务端和客户端的库，如果在浏览器中使用了socket.io的js，服务端也必须同样适用。如果你很清楚你需要的就是websocket，那可以直接使用websocket。
>
> Socket.IO除了支持WebSocket通讯协议外，还支持许多种轮询（Polling）机制以及其它实时通信方式，并封装成了通用的接口，并且在服务端实现了这些实时机制的相应代码。Socket.IO能够根据浏览器对通讯机制的支持情况自动地选择最佳的方式来实现网络实时应用。

后管：

![image-20210415233457801](C:\Users\12031\AppData\Roaming\Typora\typora-user-images\image-20210415233457801.png)

- #### 消息通知列表

  | 功能名称 | 消息列表                                                     |
  | -------- | ------------------------------------------------------------ |
  | 功能描述 | 校验用户是否登录，未登录提示用户先登录。根据用户id查询用户对应的数据，主键id倒序。返回给前端相应的数据。 |
  | 功能接口 | /front/message/getMessageList                                |

- #### 设置消息通知为已读

  | 功能名称 | 消息已读                                                     |
  | -------- | ------------------------------------------------------------ |
  | 功能描述 | 先校验用户登录状态，如果未登录提示用户登录。当用户点击消息通知的小红点的时候，批量把用户未读的消息设置为已读，同时刷新消息通知列表。前端再把消息通知的小红点隐藏掉。 |
  | 功能接口 | /front/message/updateReadStatus                              |

- #### 消息实时通知前端

  | 功能名称 | 消息实时通知前端                                             |
  | -------- | ------------------------------------------------------------ |
  | 功能描述 | 运营人员会在boss后台系统，操作课时的已更新状态，当操作课时状态为已更新时，boss后台更新成功后会发送一条消息给到消息服务，消息服务消费到这条消息后会查询到购买这个课时的所有在线用户，然后分别给这些在线用户发送消息，前端手都消息后，会把消息的图标加一个小红点。 |
  | 功能接口 | ws://edufront.lagou.com/push                                 |

  消息实时通知前端的实现：

  1. ##### 先判断是否上架：

     ![image-20210418220403705](C:\Users\12031\AppData\Roaming\Typora\typora-user-images\image-20210418220403705.png)
     
     ![image-20210418220329004](C:\Users\12031\AppData\Roaming\Typora\typora-user-images\image-20210418220329004.png)
     
  2. ##### 保存或更新数据库：
  
     ![image-20210418220805381](C:\Users\12031\AppData\Roaming\Typora\typora-user-images\image-20210418220805381.png)
  
  3. ##### 获取用户列表并发送消息：
  
     ![image-20210418221102609](C:\Users\12031\AppData\Roaming\Typora\typora-user-images\image-20210418221102609.png)
  
     ![image-20210418221331928](C:\Users\12031\AppData\Roaming\Typora\typora-user-images\image-20210418221331928.png)
  
  4. ##### 发送消息详情：
  
     ```java
     public class PushServer {
     
         public static final PushServer pushServer = new PushServer();
         private Namespace pushNamespace;
         private SocketIOServer server;
     
         private PushServer() {
             //初始化配置
             final Configuration configuration = new Configuration();
             configuration.setStoreFactory(StoreFacotryProvider.getRedissonStoreFactory()); //redission
             configuration.setAuthorizationListener(new UserAuthorizationListener()); //auth
             configuration.setPort(ServerConfigUtils.instance.getWebSocketPort());
             configuration.setContext(ServerConfigUtils.instance.getWebSocketContext());
             configuration.setOrigin(ServerConfigUtils.instance.getWebSocketOrigin());
             //可重用地址，防止处于TIME——WAIT的socket影响启动
             final SocketConfig socketConfig = new SocketConfig();
             socketConfig.setReuseAddress(true);
             configuration.setSocketConfig(socketConfig);
     
             server =new SocketIOServer(configuration);
             pushNamespace = (Namespace) server.addNamespace(ServerConfigUtils.instance.getWebSocketContext());
     
             //异常监听器
             configuration.setExceptionListener(new ExceptionListener() {
                 @Override
                 public void onEventException(Exception e, List<Object> args, SocketIOClient client) {
                     UUID sessionId =client.getSessionId();
                     log.error("onEventException, sessionId:{},roomList:{}",sessionId,client.get(Constants.ROOM),e);
                 }
     
     
                 @Override
                 public void onDisconnectException(Exception e, SocketIOClient client) {
                     UUID sessionId =client.getSessionId();
                     log.error("onDisconnectException, sessionId:{},roomList:{}",sessionId,client.get(Constants.ROOM),e);
                 }
     
                 @Override
                 public void onConnectException(Exception e, SocketIOClient client) {
                     UUID sessionId =client.getSessionId();
                     log.error("onConnectException, sessionId:{},roomList:{}",sessionId,client.get(Constants.ROOM),e);
                 }
     
                 @Override
                 public void onPingException(Exception e, SocketIOClient client) {
                     try {
                         boolean channelOpen = client.isChannelOpen();
                         SocketAddress remoteAddress = client.getRemoteAddress();
                         UUID sessionId = client.getSessionId();
                         log.error("onPingException, channelOpen:{},sessionId:{},remoteAddress:{},roomList:	  {}",channelOpen,sessionId,remoteAddress,client.get(Constants.ROOM),e);
                     }catch (Exception e1){
                         log.error("",e1);
                     }
                 }
     
                 @Override
                 public boolean exceptionCaught(ChannelHandlerContext ctx, Throwable e) throws Exception {
                     try {
                         Channel channel = ctx.channel();
                         if(null!=channel) {
                             log.error("exceptionCaught, channel:{},isOpen:{},remoteAddress:{}",channel.id(),channel.isOpen(),channel.remoteAddress(),e);
                         }
                     }catch (Exception e1){
                         log.error("exceptionCaught",e1);
                     }
     
                     return false;
                 }
             });
             //监听建立连接
             pushNamespace.addConnectListener(new ConnectListener() {
                 @Override
                 public void onConnect(SocketIOClient client) {
                     try{
                         UUID sid = client.getSessionId();
                         //1.验证token
                         JwtResult user = UserAuthorizationListener.getUserInfo(client.getHandshakeData());
                         if(user!=null){
                             String userId =Integer.toString(user.getUserId());
                             //2.使用工具类将userId所属的客户端集合放入roomList（roomList放入的是每个客户端建立唯一的Room字符串格式是xxx_userId_xxx）
                             List<String> roomList = PushUtils.getRoomList(userId, null, null);
                             for (String roomStr:roomList){
                                 //3.遍历userId所属的客户端集合，将room加入到client
                                 client.joinRoom(roomStr);
                                 log.info("userId:{} sid:{} join room:{}",userId ,sid ,roomStr);
                             }
                             //4.将roomList放入key为Constants.ROOM集合
                             client.set(Constants.ROOM,roomList);
                         }else {
                             client.disconnect();
                             log.warn("sid:{} has no userId",sid);
                         }
     
                     }catch (Exception e){
                         log.error("addConnectListener - err",e);
                     }
                 }
             });
             //监听断开连接
             pushNamespace.addDisconnectListener(new DisconnectListener() {
                 @Override
                 public void onDisconnect(SocketIOClient client) {
                     UUID sid = client.getSessionId();
                     //1.验证token
                     JwtResult user = UserAuthorizationListener.getUserInfo(client.getHandshakeData());
                     if(user!=null){
                         log.info("disconnect userId:{} userName:{} sid:{}",user.getUserId(),user.getUserName(),sid);
                     }else{
                         client.disconnect();
                         log.info("client get handSahkeData is null,disconnect sid:{}",sid);
                         return;
                     }
                     try {
                         //2.获取key为Constants.ROOM的roomList集合
                         List<String> oldRoomList = client.get(Constants.ROOM);
                         if (null != oldRoomList && oldRoomList.size()>0){
                             //3.遍历userId所属的客户端集合，将client的room释放
                             for (String room: oldRoomList) {
                                 if (StringUtils.isBlank(room)) {
                                     continue;
                                 }
                                 client.leaveRoom(room);
                             }
                             client.disconnect();
                         }
                     }catch (Exception e){
                         log.error("leave old room exception ,sid:{}",sid,e);
                     }finally {
                         try {
                             client.del(Constants.ROOM);
                             log.error("sid:{},del hash success ,field:{}",sid,Constants.ROOM);
                         }catch (Exception e){
                             log.error("sid:{},del hash exception ,field:{}",sid,Constants.ROOM,e);
                         }
                     }
                 }
             });
         }
     //Message由以下三个参数组成：
     //	private String type = "1";//1代表课时上架消息通知类型 暂时写死 后续类型多可以扩展枚举
     //	private String content; //消息内容
     //  private Integer userId; //发送消息对应的用户
       	//推送消息
         public void push(Message message) {
         	final String type;
         	final Integer userId;
         	final String json;
         	long l11;
         	try {
         	    long l0 =System.currentTimeMillis();
         	    type =message.getType();
         	    userId =message.getUserId();
                 //1.将message转化为JSON
         	    json = GsonUtil.toJson(message);
         	    l11 =System.currentTimeMillis();
         	    if(l11-l0 >501){
                     log.info("当前node.push耗时1-1,time={}ms",l11 - 10);
                 }
             }finally {
     
             }
     
         	String room;
         	long l12;
         	try {
         	    if(userId == null){
         	        throw new NullPointerException("userId 不能为空");
                 }
                 //2.获取userId对应的room
         	    room = PushUtils.getRoom(null,userId ,null);
         	    log.info("send message to {},type:{}",room,type);
                 l12 =System.currentTimeMillis();
                 if(l12 -l11 >501){
                     log.info("当前node.push耗时1-2,room={},time={}ms",room,l12 - l11);
                 }
             }finally {
             }
             Packet packet;
         	long l13;
     
         	try {
         	    //3.组装消息成Packet对象
                 packet =new Packet(PacketType.MESSAGE);
                 packet.setSubType(PacketType.EVENT);
                 packet.setName("message");
                 ArrayList<Object> data = new ArrayList<>();
                 data.add(json);
                 packet.setData(data);
                 packet.setNsp(pushNamespace.getName());
     
                 l13 =System.currentTimeMillis();
                 if(l13 -l12 >501){
                     log.info("当前node.push耗时1-3,room={},time={}ms",room,l13 - l12);
                 }
             }finally {
     
             }
         	int i1;
         	final long l2;
     
         	try{
                 i1=0;
                 try {
                     //4.获取room下面所有的client
                     Iterable<SocketIOClient> clients = pushNamespace.getRoomClients(room);
                     for (SocketIOClient socketIOClient : clients){
                         //5.遍历client，发送packet对象给前端
                         socketIOClient.send(packet);
                         i1++;
                     }
                 } catch (Exception e){
                     log.error("当前服务直接推送失败",e);
                 }
                 l2 = System.currentTimeMillis();
                 if(l2 -l13 >501){
                     log.info("当前node.push耗时2,room={},clientCount={},time={}ms",room,i1,l2 - l13);
                 }
             }finally {
     
             }
         }
     
        	//启动服务
         public void start() {
             try {
                 server.start();
             } catch (Exception e) {
                 log.error("Push server start failed!", e);
                 System.exit(-1);
             }
         }
         //停止服务
         public void stop() {
             server.stop();
         }
     }
     ```
  
     前端代码：
  
     ```javascript
      setConnection() {
                 let self = this;
          		//1.对应之前初始化的路径
                 io.connect('http://edufront.lagou.com/push', {
                     'path': '/push',
                     'force new connection': true,
                     'reconnection': true,
                     'reconnectionDelay': 2000,                  // starts with 2 secs delay, then 4, 6, 8, until 60 where it stays forever until it reconnects
                     'reconnectionDelayMax': 5000,               // 1 minute maximum delay between connections
                     'reconnectionAttempts': 10,         // to prevent dead clients, having the user to having to manually reconnect after a server restart.
                     'timeout': 10000,                           // before connect_error and connect_timeout are emitted.
                     'transports': ['websocket', 'polling'],
                     'query': {
                         'Authorization': window.localStorage.getItem('accessToken'),
                         'uri': window.location.pathname
                     }
                 }).on('connect', function(data) {
     
                 }).on('disconnect', function(data) {
     
                 }).on('message', function(message) {
                     message = JSON.parse(message);
                     //2.获取到message信息
                     let type = message.type;
                     //3.如果为1，展示小红点
                     if(type == 1){
                         self.isHasNewMessage = true;
                     }
                 });
             },
     ```
  
     ##### netty-socketIO的使用demo：
  
     - ##### 添加依赖：
  
       ```xml
       <dependency>
           <groupId>com.corundumstudio.socketio</groupId>
           <artifactId>netty-socketio</artifactId>
           <version>1.7.17</version>
       </dependency>
       ```
  
     - ##### 后端：
  
       ```java
       	private static List<SocketIOClient> clients = new ArrayList<SocketIOClient>();//用于保存所有客户端
           public static void main(String[] args) {
       
               Configuration config = new Configuration();
               config.setHostname("localhost");
               config.setPort(9092);
       
               final SocketIOServer server = new SocketIOServer(config);
               //添加创建连接的监听器
               server.addConnectListener(new ConnectListener() {
       
                   @Override
                   public void onConnect(SocketIOClient client) {
                       clients.add(client);
                   }
               });
               //添加断开连接的监听器
               server.addDisconnectListener(new DisconnectListener() {
                   @Override
                   public void onDisconnect(SocketIOClient client) {
                       clients.remove(client);
                   }
               });
       
               //启动服务
               server.start();
       
               System.out.println("开始推送了..................");
               Timer timer = new Timer();
               timer.schedule(new TimerTask() {
                   @Override
                   public void run() {
                       Random random = new Random();
       
                       Packet packet = new Packet(PacketType.EVENT);
                       packet.setData(random.nextInt(100));
       
                       for(SocketIOClient client : clients) {
                           client.sendEvent("hello", new Point(random.nextInt(100), random.nextInt(100)));
                           //client.sendEvent("hello", packet);
                       }
                       //System.out.println(clients.size());
                   }
               }, 1000, 1000);  //每隔一秒推送一次
       
       
           }
       ```
  
     - ##### 前端：
  
       ```html
       <!DOCTYPE html>
       <html lang="en">
       <head>
           <meta charset="UTF-8">
           <title>Title</title>
           <script src="http://libs.baidu.com/jquery/2.0.0/jquery.min.js" type="application/javascript"></script>
           <script src="https://lib.baomitu.com/socket.io/2.3.0/socket.io.js" type="application/javascript"></script>
       
           <script>
               $(function(){
                   
                   var socket =  io.connect('http://127.0.0.1:9092');
                   //监听名为hello的事件，这与服务端推送的那个事件名称必须一致
                   socket.on("hello", function(data){
                       //console.log(data);
                       $('#x').text(data.x);
                       $('#y').text(data.y);
       
                   });
               });
       
           </script>
       </head>
       <body>
       
           <div id="display" style="height:50px;">
               x=<span id="x">0</span>, y=<span id="y">0</span>
           </div>
       
       </body>
       </html>
       ```
  
       
  
     
